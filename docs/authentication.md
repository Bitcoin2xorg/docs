# eToroX Authentication

At eToroX we value our clients security.

For each authenticated end-point, user must prove his identity.
The authentication process was built to make sure user identity cannot be stolen or forged.

> Don't share your private keys! eToroX will never ask you to share or send your private keys

## Authenticated end-points
At the moment eToroX provides two transports of communications both are diffenernt in the interface these provide.
Both share the same process and properties of authentication.
Authenticated end-points:
* [HTTPS authentication](https-api)
* [Websockets authentication](websockets-api)


## Access to eToroX API
Access to eToroX API allowed only to verified users.
with *developer app* verified users can manage thier *Developer app* *API tokens* from the Website UI.

### Developer APP
*Developer app* enables access to eToroX API.

Every *developer app* provides the following information:
* HTTPS API - A private DNS for https access.
* Websockets - A private DNS for websocekts access
The properties are always available from the trading API settings section on the Website UI.

*At the moment any request for developer application is reviewed by costumers support and manually approved.*

### API tokens
The *API tokens* are generated based on the *developer app*.
User can manage multiple *API tokens*, each *API token* can be identified by custome meaningful token name.

When tokens are generated, the following information will become accessible:
* API key - A UUID id of this token.
* Private key - A private key used by signing action.

*This information cannot be retrieved and must be stored by the user*

## Benifits of authentication process
* Access to API granted by creating specifc *API tokens*.
* *API token* can only be created with 2FA verification.
* *API token* data only avilable during creation.
* *API token* credentials comprised from an asymmetric RSA private/public key pair.
* During *API token* creation user recived private key in order to sign data.
* eToroX stores only the asymmetric public key _even read access to our servers will not provide attacker the ability to forge user identity_ .
* As part of authentication process eToroX mitigates man in the middle attacks by using combination of TLS encription, timestamp and nonce validations with asymmetric signature signing - no sensitive information should be passed in API communication.
* As part of authentication process eToroX mitigates replay attacks by verifying both nonce and timestamp verifications.
* *API tokens* persmissions can be scoped when created - Scoping makes sure a token may be used only for specific actions.
* *API tokens* detials are immutable these can always be deleted but never changed or retrived.

## Authentication process
Authenticaiton process requires the following paramters:
* API key - A UUID identifies this token.
* Private key - asymmetric RSA private key should *never* be shared.
* Timestamp - Unix timestamp of the moment the singaure was created.
* Nonce - a unique number.

eToroX servers verifies user identity based on:
* API key. 
* Signaute - details of how to create signature is in the following section.
* Timestamp.
* Nonce.

### Create a signature
Asymetric signatures are generated by the user in order to prove to eToroX servers that the user has access to his private key.
eToroX confirms this by running a similar but asymetric process with the public key equivalence.

The following parameters are used for signature generation:
* API key.
* Private key.
* Nonce.
* Unix timestamp.

#### Private key
The private keys generated by eToroX are:
* `PKCS8` encoded.
* `PEM` formated.
* Chiper `AES-256-CBC`
* Empty string as the passphrase `` .

*Some libreries may requires the user to convert the private key into different encoding, such convertion process is possible by using `openssl` command line tool.*

#### Signing process

The payload the user signs is a concatination of the `unix timestamp` and `nonce`.
```js
const payload = `${timestamp}${nonce}`;
```

The payload should be singed with a `SHA256` signature algorithm and result should be `base64` encoded.

```js
const payload = `${timestamp}${nonce}`;
const signer = crypto.createSign('sha256');
signer.update(`${nonce}${timestamp}`);
signature = signer.sign(privateKey, 'base64');
```

